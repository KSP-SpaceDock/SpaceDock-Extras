/*
 CKAN extension for SpaceDock Backend

 SpaceDock-Extras is licensed under the Terms of the MIT License.
 Copyright (c) 2017 Dorian Stoll (StollD), RockyTV
*/

package ckan

import (
    "github.com/KSP-SpaceDock/SpaceDock-Backend/app"
    "github.com/KSP-SpaceDock/SpaceDock-Backend/middleware"
    "github.com/KSP-SpaceDock/SpaceDock-Backend/objects"
    "github.com/KSP-SpaceDock/SpaceDock-Backend/routes"
    "bytes"
    "context"
    "encoding/json"
    "github.com/google/go-github/github"
    "github.com/spf13/cast"
    "gopkg.in/kataras/iris.v6"
    "os"
    "os/exec"
    "path/filepath"
    "regexp"
    "strconv"
    "strings"
    "text/template"
)

type CKANSettings struct {
    NetkanRepoPath string `yaml:"netkan-repo-path" json:"netkan-repo-path"`
    GithubUser string `yaml:"github-user" json:"github-user"`
    GithubPass string `yaml:"github-pass" json:"github-pass"`
    KspGameshort string `yaml:"ksp-gameshort" json:"ksp-gameshort"`
    ProfileUrl string `yaml:"profile-url" json:"profile-url"`
}

var cfg CKANSettings

func init() {
    app.LoadFromConfigFile(&cfg, "ckan.yml")
    routes.Register(routes.POST, "/api/mods/:gameshort/:modid/ckan",
        middleware.NeedsPermission("mod-edit", true, "gameshort", "modid"),
        mods_ckan,
    )
}

/*
 Path: /api/mods/:gameshort/:modid/ckan
 Method: POST
 Description: Returns information for one mod
 */
func mods_ckan(ctx *iris.Context) {
    // Get params
    gameshort := ctx.GetString("gameshort")
    modid := cast.ToUint(ctx.GetString("modid"))

    // Check the gameshort
    if gameshort != cfg.KspGameshort {
        utils.WriteJSON(ctx, iris.StatusBadRequest, utils.Error("It's called KERBAL Archive Network, right?").Code(3110))
        return
    }

    // Get the mod
    mod := &objects.Mod{}
    app.Database.Where("id = ?", modid).First(mod)
    if mod.ID != modid {
        utils.WriteJSON(ctx, iris.StatusNotFound, utils.Error("The modid is invalid").Code(2130))
        return
    }
    if mod.Game.Short != gameshort {
        utils.WriteJSON(ctx, iris.StatusBadRequest, utils.Error("The gameshort is invalid.").Code(2125))
        return
    }
    if !mod.Published {
        utils.WriteJSON(ctx, iris.StatusForbidden, utils.Error("The mod is not published").Code(3020))
        return
    }

    // Add to CKAN
    mod.SetValue("ckan", true)
    url := AddModToCKAN(mod)
    if url != "" {
        utils.WriteJSON(ctx, iris.StatusOK, iris.Map{"error": false, "count": 1, "data": url})
        return
    } else {
        utils.WriteJSON(ctx, iris.StatusInternalServerError, utils.Error("Something went wrong with your request").Code(5000))
        return
    }
}

func AddModToCKAN(mod objects.Mod) string {
    if cfg.NetkanRepoPath == "" {
        return ""
    }
    err, val := mod.GetValue("ckan")
    if err == nil {
        if !cast.ToBool(val) {
            return ""
        }
    } else {
        return ""
    }
    json_blob := map[string]string {
        "spec_version": "v1.4",
        "identifier":   regexp.MustCompile("\\W+").ReplaceAllString(mod.Name, ""),
        "$kref":        "#/ckan/spacedock/" + cast.ToString(mod.ID),
        "license":      mod.License,
        "x_via":        "Automated SpaceDock CKAN submission",
    }
    path := filepath.Join(cfg.NetkanRepoPath, "NetKAN", json_blob["identifier"] + ".netkan")
    if _, err := os.Stat(path); !os.IsNotExist(err) {
        // The mod already exists in the repository
        return ""
    }

    // Save the file
    out, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
        return ""
    }
    b, err := json.MarshalIndent(json_blob, "", "    ")
    out.Write(b)
    out.Close()
    olddir,_ := os.Getwd()
    os.Chdir(cfg.NetkanRepoPath)
    exec.Command("git" ,"fetch", "upstream")
    exec.Command("git", "checkout", "-b", "add-" + json_blob["identifier"], "upstream/master")
    exec.Command("git", "add", "-A")
    exec.Command("git", "commit", "-m", "Add " + mod.Name + " from " + app.Settings.SiteName + "\n\nThis is an automated commit on behalf of " + mod.User.Username, "--author=" + mod.User.Username + " <" + mod.User.Email + ">")
    exec.Command("git", "push", "-u", "origin", "add-" + json_blob["identifier"])
    os.Chdir(olddir)

    // Template
    t := template.Must(template.New("email").Parse(`
This pull request was automatically generated by SpaceDock on behalf of {0}, to add [{1}]({4}{2}) to CKAN.

Mod details:
    name = {2}
    author = {0}
    abstract = {6}
    license = {7}
    description = {5}

Please direct questions about this pull request to [{0}]({4}{3}).`))
    buf := &bytes.Buffer{}
    err, modURL := mod.Game.GetValue("modURL")
    if err != nil {
        modURL = ""
    }
    err, profileURL := mod.Game.GetValue("profileURL")
    if err != nil {
        profileURL = ""
    }
    data := map[string]string {
        "0": mod.User.Username,
        "1": mod.Name,
        "2": create_mod_url(mod.ID, mod.Name, modURL),
        "3": create_profile_url(mod.User.ID, mod.User.Username, profileURL),
        "4": app.Settings.Protocol + "://" + app.Settings.Domain,
        "5": mod.Description,
        "6": mod.ShortDescription,
        "7": mod.License,
    }
    if err := t.Execute(buf, data); err != nil {
        return ""
    }
    s := buf.String()

    // Create a pull request
    tp := github.BasicAuthTransport{
        Username: cfg.GithubUser,
        Password: cfg.GithubPass,
    }
    client := github.NewClient(tp.Client())
    p, _, _ := client.PullRequests.Create(context.Background(), "KSP-CKAN", "NetKAN", &github.NewPullRequest{
        Title: "Add " + mod.Name + " from " + app.Settings.SiteName,
        Base: &"KSP-CKAN:master",
        Head: &(cfg.GithubUser + ":add-" + json_blob["identifier"]),
        Body: &s,
        MaintainerCanModify: &true,
    })
    return *p.URL
}

func create_mod_url(id uint, name string, modURL string) string {
    if modURL == "" {
        modURL = app.Settings.ModUrl
    }
    return strings.Replace(strings.Replace(modURL, "{id}", strconv.Itoa(int(id)), -1), "{name}", name, -1)
}

func create_profile_url(id uint, name string, profileURL string) string {
    if profileURL == "" {
        profileURL = cfg.ProfileUrl
    }
    return strings.Replace(strings.Replace(profileURL, "{id}", strconv.Itoa(int(id)), -1), "{name}", name, -1)
}